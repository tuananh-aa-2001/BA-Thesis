\documentclass[a4paper,12pt]{scrreprt}
\usepackage[ngerman]{babel}
\usepackage[left=2cm,right=2cm,top=2.5cm,bottom=2.5cm]{geometry}
\usepackage{amsmath}
\usepackage{acronym}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{makeidx}
\usepackage{graphicx}
\usepackage{epstopdf}
\usepackage{kpfonts}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{textcomp}
\usepackage[onehalfspacing]{setspace}
\usepackage[colorlinks=true, allcolors=blue]{hyperref}
\usepackage[backend=biber,style=apa]{biblatex}
\addbibresource{references.bib}
\newcommand{\dcplace}{Aachen}
\newcommand{\dcdate}{04. Mai 2025}
\newcommand{\dcauthorfirstname}{Max}
\newcommand{\dcauthorlastname}{Mustermann}

\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{\nouppercase{\leftmark}} % Kapitelname in normaler Schrift
\fancyhead[R]{} 
\setlength{\parindent}{0pt}
\fancyfoot[C]{\thepage} 

\usepackage{listings}
\usepackage{xcolor}
\definecolor{bggray}{gray}{0.95}
\definecolor{codeblue}{rgb}{0.1, 0.1, 0.8}
\definecolor{codered}{rgb}{0.8, 0.1, 0.1}
\definecolor{codegreen}{rgb}{0.1, 0.6, 0.1}
\definecolor{codeorange}{rgb}{0.9, 0.5, 0.1}
\lstset{
	basicstyle=\ttfamily\small\color{codeblue},
	backgroundcolor=\color{bggray},
	keywordstyle=\color{codered}\bfseries,
	stringstyle=\color{codegreen}, 
	commentstyle=\color{gray}\itshape, 
	breaklines=true, 
	showspaces=false,
	showstringspaces=false,
	showtabs=false,
	tabsize=2
}
\lstdefinelanguage{properties}{
	morecomment=[l]{\#},
	morecomment=[s]{/*}{*/},
	morestring=[b]",
	basicstyle=\ttfamily\small\color{codeblue},
	keywordstyle=\color{codeorange}\bfseries,
	commentstyle=\color{codegreen}\itshape,
	backgroundcolor=\color{bggray},
	breaklines=true,
	showspaces=false,
	showstringspaces=false,
	showtabs=false,
	tabsize=2
}
\lstdefinelanguage{POM}{
	language=XML,
	basicstyle=\ttfamily\small\color{codeblue},
	keywordstyle=\color{codeorange}\bfseries,
	stringstyle=\color{codegreen},
	backgroundcolor=\color{bggray},
	morekeywords={dependency, groupId, artifactId, version, dependencies},
	breaklines=true,
	showspaces=false,
	showstringspaces=false,
	showtabs=false,
	tabsize=2
}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{
	language=Java,
	aboveskip=3mm,
	belowskip=3mm,
	showstringspaces=false,
	columns=flexible,
	basicstyle={\small\ttfamily},
	numbers=left,
	numberstyle=\tiny\color{black},
	stepnumber=1,
	numbersep=10pt,
	keywordstyle=\color{blue},
	commentstyle=\color{dkgreen},
	stringstyle=\color{mauve},
	breaklines=true,
	breakatwhitespace=true,
	tabsize=3,
	inputencoding=utf8,
	literate={ä}{{\"a}}1 {ö}{{\"o}}1 {ü}{{\"u}}1 {Ä}{{\"A}}1 {Ö}{{\"O}}1 {Ü}{{\"U}}1 {ß}{{\ss}}1
}

\usepackage{float}

\begin{document}
	\begin{titlepage}
		%ab hier kleinere Raender, mehr bedruckbare Flaeche.
		\thispagestyle{empty}
		\newgeometry{a4paper, portrait, left=1.0cm, right=0cm, top=0.6cm, bottom=0cm, includefoot}
		
		\noindent
		\begin{minipage}[t]{0.5\textwidth}
			\includegraphics[width=3.7cm]{firmenlogo.jpg}
		\end{minipage}%
		\begin{minipage}[t]{0.5\textwidth}
			\raggedleft
			\includegraphics[width=1.7cm]{FHAC.jpg}
		\end{minipage}
		
		\vspace{1.0cm}
		
		% Kopfzeile mit Fachbereich ...
		{\centering \bfseries \Large FH~Aachen \\
			\vspace{1cm}
			\normalsize Fachbereich\\
			Elektrotechnik und Informationstechnik \\
			Studiengang~Informatik \par}
		
		\vspace{1cm}
		
		{\centering \bfseries \large Bachelorarbeit \par}
		
		\vspace{1cm}
		
		\centering \begin{minipage}[t]{13cm}
			\centering \small Konzeption und prototypische Entwicklung einer Webanwendung für Messdatenerhebung und -bereitstellung
			\medskip
		\end{minipage}
		
		\vspace{1.5cm}
		
		%\vspace*{1cm}
		%\hspace*{6.8cm}
		\begin{minipage}[t]{9cm}
			\centering Tuan Anh Cong Nguyen \\ Matr.-Nr.: 3517392
		\end{minipage}
		\vspace{2.1cm}
		
		%\vspace*{4.7cm}
		%\hspace*{6.8cm}
		\centering \begin{minipage}[b]{15cm}
			\centering
			Referent: Prof. Dr. rer. nat. Heinrich Faßbender\\
			%Korreferent: Prof. Dr.-Ing. ...\
		\end{minipage}
		
		
		\vspace{1.5cm}
		
		%Erstellungsdatum
		%\vspace{-4cm}
		%\begin{flushright}
		\centering %\hspace{8cm}
		\begin{minipage}[b]{10cm}
			\centering
			In Zusammenarbeit mit Ausbildungsbetrieb:\\
			ahu GmbH Wasser Boden Geomatik \\
			\vspace{1cm}
			Externer Betreuer: Dr. David Loibl
			
			%\today\\ %Datum\\
			%\vspace{1cm}
			%vertraulich bis xx.xx.xx
		\end{minipage}
		%\end{flushright}
		
		%\today
		\restoregeometry
	\end{titlepage}
	
	\clearpage % Neue Seite für Selbstständigkeitserklärung
	\chapter*{Selbstständigkeitserklärung}
	\thispagestyle{empty}	%keine Seitenzahl!
	\pdfbookmark{Selbstständigkeitserklärung}{Selbstständigkeitserklärung}
	Ich versichere hiermit, dass ich die vorliegende Arbeit selbständig verfasst und keine anderen als die im Literaturverzeichnis angegebenen Quellen benutzt habe.\\ \\
	Stellen, die wörtlich oder sinngemäß aus veröffentlichten oder noch nicht veröffentlichten Quellen entnommen sind, sind als solche kenntlich gemacht.\\ \\ Die Zeichnungen oder Abbildungen in dieser Arbeit sind von mir selbst erstellt worden oder mit einem entsprechenden Quellennachweis versehen.\\ \\ Diese Arbeit ist in gleicher oder ähnlicher Form noch bei keiner anderen Prüfungsbehörde eingereicht worden.\\ \\[2ex]
	Aachen, den \today \hspace{4cm} \dotfill 
	\tableofcontents
	
	\clearpage
	\chapter*{Abkürzungsverzeichnis}\label{abkuerzungsverzeichnis}
	\begin{acronym}[\hspace{3cm}]
		\acro{REST-API}{Representational State Transfer Application Program Interface}
		\acro{OGC}{Open Geospatial Consortium}
		\acro{WMS}{Web Map Server}
		\acro{WFS}{Web Feature Server}
		\acro{JSON}{JavaScript Object Notation}
		\acro{CSV}{Comma Separated Values}
		\acro{ASCII}{American Standard Code for Information Interchange}
		\acro{QGIS}{Quantum Geographic Information System}
		\acro{UI}{User Interface}
		\acro{HTML}{Hypertext Markup Language}
		\acro{CSS}{Cascading Style Sheets}
		\acro{HTTP}{Hypertext Transfer Protocol}
		\acro{URL}{Uniform Resource Locator}
		\acro{AJAX}{Asynchronous JavaScript and XML}
		\acro{J2EE}{Java 2 Platform, Enterprise Edition}
		\acro{XML}{Extensible Markup Language}
		\acro{JAR}{Java Archive}
		\acro{WAR}{Web Application Archive}
		\acro{JPA}{Java Persistence API}
		\acro{CRUD}{Create, Raed, Update and Delete}
		\acro{UUID}{Universally Unique Identifier}
	\end{acronym}
	
	\cleardoublepage
	\chapter*{Abstract}
	\thispagestyle{plain}
	\addcontentsline{toc}{chapter}{Abstract}
	In einer zunehmend digitalisierten und automatisierten Welt wächst die Menge neu generierter Geodaten – insbesondere Mess- und raumbezogene Daten - kontinuierlich.\\ \\
	Die Recherche nach relevanten Messdaten wie Grundwasserständen, Pegelständen und Klimadaten (Niederschlag,Temperatur), sowie deren Umformatierung in ein einheitliches Format stellt eine erhebliche Herausforderung dar. Dies liegt vor allem an der Vielzahl unterschiedlicher Datenanbietern, die jeweils eigene Datenstrukturen und -formate verwenden.\\ \\
	Die Bereitstellung dieser Rohdaten erfolgt häufig im CSV-Format oder als individuell strukturierte ASCII-Dateien. Im Kontext der Ahu GmbH werden diese Daten über den sogenannten \textbf{ahuManager} konsumiert. Vor der Weiterverarbeitung müssen die Rohdaten jedoch in ein kompatibles Zielformat umgewandelt werden - ein Vorgang, der bislang teilweise manuell (z.B. mithilfe von Excel) durchgeführt wird. Diese manuelle Datenaufbereitung ist zeitaufwendig, fehleranfällig und nur begrenzt skalierbar. \\ \\
	Ziel dieser Arbeit ist es daher, zu untersuchen, wie eine webbasierte Applikation zur automatisierten Umwandlung und Bereitstellung von Messdaten konzipiert und prototypisch umgesetzt werden kann.
	\clearpage
	\chapter{Einleitung}
	\section{Motivation der Arbeit}
	Diese Bachelorarbeit entsteht in Kooperation mit dem Bereich Geomatik der Ahu GmbH, der sich auf die Konzeption und Entwicklung von Monitoringsysteme sowie Webanwendungen spezialisiert hat.Ziel ist es, Dienstleitern, Betreibern und Aufsichtsbehörden ein kosteneffizientes Management von Geodaten - wie etwa Grundwasser-, Oberflächenwasser-, und Bodendaten- zu ermöglichen. \\\\
	Aktuell besteht ein Bedarf an einem zentralen System, das eine automatisierte Suche, Aggregation und Verwaltung von Geodaten aus unterschiedlichen externen Datenquellen ermöglicht. Ziel ist es, diese heterogenen Daten in eine homogene Struktur zu überführen und sie einem bestehenden Client-System, wie dem \textbf{AhuManager}, standardisiert bereitzustellen.
	
	\section{Ziel der Arbeit}
	Das Ziel dieser Bachelorarbeit besteht in der Konzeption und prototypischen Umsetzung einer webbasierten Anwendung zur Erhebung und Bereitstellung von Messdaten. Ein zentrales Anliegen ist die Entwicklung einer übergreifenden Suchfunktion für Geodaten sowie deren Umwandlung in ein definiertes Zielformat. \\ \\ 
	Durch die Umsetzungen dieser Funktionalitäten soll perspektivisch eine Software entstehen, die eine praktikable Lösung für bestehende Herausforderungen in der Verarbeitung und Bereitstellung heterogener Messdaten bietet.
	\clearpage
	\section{Aufbau der Arbeit}
	\section*{\small \textbf{Kapitel 1: Einleitung}}
	Im ersten Kapitel werden die Motivation sowie die Zielsetzung der Arbeit erläutert. Es wird auf die Relevanz des gewählten Themas eingegangen, welchen potenziellen Nutzen die prototypische Entwicklung für das Unternehmen bieten kann.
	\section*{\small \textbf{Kapitel 2: Technologischer Überblick}}
	Dieses Kapitel stellt die in der Entwicklungsphase eingesetzten Technologien und relevanten Begriffe vor - von Bibliotheken zur Verfolgung der Datenbankänderungen über das verwendete Backend-Framework bis hin zum verwendeten UI-Framework für die Benutzeroberfläche.   
	\section*{\small \textbf{Kapitel 3: Anforderungsanalyse und Spezifikation}}
	In diesem Kapitel werden verschiedene User-Stories definiert und daraus Use-Cases abgeleitet. Die funktionalen sowie nicht-funktionalen Anforderungen an das System werden spezifiziert und dokumentiert.
	\section*{\small \textbf{Kapitel 4: Konzeption und Architektur}}
	In diesem Kapitel wird das zugrunde liegende Architekturdesign des Prototyps aus unterschiedlichen Sichten erläutert. Die getroffenen Architekturentscheidungen werden begründet und mit gängigen Architekturmustern verglichen.
	\section*{\small \textbf{Kapitel 5: Implementierung}}
	Die tatsächliche Umsetzung des Prototyps wird anhand ausgewählter Codebeispiel und technischer Erläuterung detailliert dargestellt. Dabei wird auf zentrale Aspekte wie Datenverarbeitung, Schnittstellenlogik und UI-Integration eingegangen.
	\section*{\small \textbf{Kapitel 6: Fazit und Ausblick}}
	Abschließend erfolgt eine kritische Bewertung der erreichten Ergebnisse im Hinblick auf die zu Beginn definierten Anforderungen. Zudem wird ein Ausblick auf möglich Weiterentwicklung und Optimierungspotenziale gegeben.
	
	\chapter{Technologischer Überblick}
	\section{Vaadin}
	Vaadin ist ein serverseitiges Web-Framework, das dem Entwickler erlaubt, moderne Webanwendung in Java zu entwickeln, ohne dass explizit HTML,CSS oder JavaScript geschrieben werden muss. Vaddin verfügt über eine große Komponentenbibliothek, die eine Vielzahl an vorgefertigten UI-Elementen wie Buttons, Tabellen, Formulare, Dialoge und Layouts bietet.
	
	\begin{figure}[h!]
		\centering
		\includegraphics[width=9cm, height=10cm]{vaadin_architekture.jpg}
		\caption{\label{vaadin:architektur}Übersicht Vaadin Architektur \cite{architecture21}}
	\end{figure}
	Vaadin verfolgt einen serverseitigen Rendering-Ansatz. Während eine AJAX-basierte Vaadin Client-Side Engine dafür sorgt, dass die Benutzeroberfläche im Browser durch ein Widget-Set gerendert wird. Die Benutzeroberfläche kann aus eingebauten Komponenten, Add-Ons und benutzerdefinierten Komponenten bestehen. Diese Client-Side Engine kommuniziert über HTTP oder WebSockets mit dem Server. Die gesamte UI-Logik wird dann auf dem Server ausgeführt. Die Vaadin Servlet empfängt Client-Anfragen und aktualisiert die Benutzeroberfläche. Die UI-Komponenten werden serverseitig erstellt und verwaltet. Änderungen in der UI werden durch die Vaddin Client-Side Engine an den Browser zurückgespielt.  
	
	\section{Spring Framework}
	Spring Framework ist ein Java-Framework, das um 2003 als Reaktion auf die damals noch zu komplizierte J2EE-Plattform entwickelt wurde. Spring ermöglicht eine einfachere und unkompliziertere Entwicklung von Enterprise-Applikation in Java. Eines der wichtigsten Konzepte von Spring war die Inversion of Control (IoC).
	IoC ist ein Prinzip, bei dem der Kontrollfluss an eine externe Quelle(z.B. ein Framework) übergeben wird. Das Framework ist dann gemäß einer Spezifikation für die Erstellung und Löschung der Objekte und den Aufruf von Methoden verantwortlich. \\ \\ Spring führt das Konzept des Bean-Containers ein. Beans sind Java-Objekte, die von Spring instanziiert und verwaltet sind. Wenn die Haupt-Bean von der Hilfs-Bean abhängig ist, stellt Spring sicher, dass die Hilfs-Bean vor der Haupt-Bean initialisiert wird. Spring injizierte außerdem die Instanz der Hilfs-Bean in die Haupt-Bean, sodass die Haupt-Bean nicht mehr nach ihren eigenen Abhängigkeiten suchen muss. Dieses Muster wird als Dependendy Injection bezeichnet.\\ \\
	Damals musste der Entwickler die Bean-Konfiguration in XML schreiben, die Spring anweist, wie die Beans zu konstruieren sind. Inzwischen wird diese mithilfe einer Kombination aus Java-Annotation, Java-Code und Konventionen erstellt.
	\section{Spring Boot}
	Mit dem Wachstum der Spring-Plattform nahm auch die Komplexität der Entwicklung von Spring-Anwendungen zu. Gleichzeitig verbreitet sich der Einsatz von Microservices und containerisierten Umgebungen in der Softwareentwicklung. Entwickler wünschten sich einfach Methode, um schlanke Webanwendungen zu erstellen, die unabhängig als eigenständige Dienst ausgeführt werden können, anstatt auf einem dedizierten Anwendungsserver zu laufen.\\ \\
	Spring Boot wurde als Reaktion auf diese Anforderungen entwickelt. Es erleichtert die Erstellung von Spring-Anwendungen durch sinnvolle Standard-Einstellungen, Starter-Abhängigkeiten und produktionsreife Funktionen für Konfiguration und Überwachung. Durch die Einführung eingebetteter Servlet-Container wurde es möglich, Anwendungen als eigenständige, ausführbare JAR-Dateien zu verpacken. 
	\section{Maven}
	Maven ist ein Build-Management- und Projektverwaltungswerkzeug, das häufig in der Java-Entwicklung eingesetzt wird. Es automatisiert Aufgaben wie das Herunterladen von Abhängigkeiten, das Kompilieren von Quellcode und das Ausführen von Builds sowie Tests. Maven verwendet eine zentrale Konfigurationsdatei, die \texttt{pom.xml}, um alle Aspekte des Projekts wie Libraries, Plugins und Build-Prozesse zu steuern.\\ \\
	Die Funktionsweise von Maven basiert auf einem deklarativen Ansatz. Das bedeutet, dass der Entwickler alle relevanten Informationen über das Projekt in einer zentralen Konfigurationsdatei, der sogenannten \texttt{pom.xml}( Projekt Object Model) angibt, wie z.B. Abhängigkeiten, Build-Prozesse und Plugins : \cite{deinhard24}.
	\section*{\small \textbf{1. Die pom.xml-Datei (Project Object Model)}}
	Die \texttt{pom.xml} ist das Herzstück eines Maven-Projekts. Sie enthält Informationen wie:
	\begin{itemize}
		\item Projektinformationen: Name des Projekts, Version, Beschreibung.
		\item Abhängigkeiten: Welche Bibliotheken und Framworks das Projekt benötigt.
		\item Plugins: Zusätzliche Werkzeuge, die den Build-Prozess erweitern (z.B. Compiler-Plugins, Test-Frameworks).
		\item Repositories: Woher Maven externe Abhängigkeiten herunterladen soll, typischerweise das Maven Central Repository.
		\item Build-Spezifikationen: Kompilierungsanweisungen, Testkonfigurationen und Deployment-Optionen.
	\end{itemize}
	\section*{\small \textbf{2. Build-Lifecycle}}
	Maven besitzt einen vordefinierten Build-Lifecycle, der aus mehreren Phasen besteht. Zu den wichtigsten Phasen gehören:
	\begin{itemize}
		\item validate: Überprüft, ob alle erforderlichen Informationen im Projekt vorhanden sind.
		\item compile: Kompiliert den Quellcode.
		\item Führt automatisierte Tests aus.
		\item package: Verpackt den kompilierten Code in ein Distributionsformat, typischerweise eine JAR- oder WAR-Datei.
		\item install: Installiert das Paket in das lokale Maven-Repository, damit es in anderen Projekten verwendet werden kann.
	\end{itemize}
	
	\section{Vaadin Initializer}
	Gegenüber dem üblichen \href{https://start.spring.io/} {Spring Initializer}, der ein vorkonfiguriertes Spring-Projekt bereitstellt, bietet der \href{https://start.vaadin.com/app/p} {Vaadin Initializer} den Vorteil, dass er speziell auf Vaadin-Projekte zugeschnitten ist und eine vereinfachte und schnellere Projektgenerierung ermöglicht, insbesondere wenn man Spring Boot als Backend verwendet.\\ \\ Mit dem Vaadin- Initializer kann man direkt ein Vaadin Flow-basiertes Projekt mit einem Spring Boot-Backend erstellen, während man mit dem Spring Initializer ein allgemeines Spring Boot-Projekt generiert und dann manuell die Vaadin-Abhängigkeiten hinzufügen muss.
	
	\section{Liquibase}
	Dank Versionsverwaltung wie Git kann man in den meisten Projekten den Weg einer Code-Änderung von der der Entwicklung über Test bis hin zum produktiven Deployment richtig verfolgen und nachvollziehen. Was für den Code gilt, sollte auch für die Datenbankanpassungen gelten. Liquibase ist eine Bibliothek um Änderungen an einem Datenbankschema verfolgen, verwalten und anwenden zu können. Mit folgendem Eintrag in \texttt{pom.xml} kann man in ein Spring-Projekt integrieren.
\begin{lstlisting}[language=POM]
<dependency>
		<groupId>org.liquibase</groupId>
		<artifactId>liquibase-core</artifactId>
		<version>4.23.1</version>
</dependency>
\end{lstlisting}
	Für die Speicherung der Daten wird die PostgreSQL-Datenbank entschieden. PostgreSQL selbst eine leistungsstarke, offene Datenbank, die kompatibel zu Liquibase passt. Die Aktivierung der Datenbank wird in der Datei \texttt{application.properties} innerhalb der Spring-Applikation wie folgt konfiguriert:
\begin{lstlisting}[language=properties]
spring.datasource.url=jdbc:postgresql://192.168.252.140:5432/opendataconn_ng
spring.datasource.driver-class-name=org.postgresql.Driver
spring.datasource.username=opendataconn_ng_usr
spring.datasource.password=
spring.jpa.database-platform=org.hibernate.dialect.PostgreSQLDialect
spring.liquibase.change-log=classpath:/db/changelog-root.xml
\end{lstlisting}
	Für die Verwendung von Liquibase sind folgende Dateien notwendig:
	\begin{figure}[h!]
		\centering
		\includegraphics[width=9cm, height=3cm]{liquibase-changelog.png}
		\caption{\label{datenbank:konfiguration} Liquibase-Konfiguration}
	\end{figure}
	\section*{\small \textbf{1. Liquibase Konfiguration - liquibase.properties}}
	In dieser Datei werden allgemeine Einstellungen wie der Datenbankzugang und die zu verwendenden Changelog-Konfiguration festgelegt.
\begin{lstlisting}[language=properties]
# Database Configuration
url=jdbc:postgresql://192.168.252.140:5432/opendataconn_ng
username=opendataconn_ng_usr
password=
driver=org.postgresql.Driver
# Reference Configuration
referenceUrl=hibernate:spring:de.ahu.opendata?dialect=
org.hibernate.dialect.PostgreSQLDialect
referenceDriver=liquibase.ext.hibernate.database.connection.HibernateDriver
# Output Files
changeLogFile=src/main/resources/db/changelog-root.xml
diffChangeLogFile=src/main/resources/db/liquibase-new-diff-changelog.xml
outputChangeLogFile=src/main/resources/db/versions/output-changelog.xml
\end{lstlisting}
	\section*{\small \textbf{2. Changelog Konfiguration - changelog-root.xml}}
	Ein so genannter Root-ChangeLog wird erstellt, welcher in XML geschrieben ist und eine output-changelog.xml inkludiert, welche im Ordner ,,versions'' zu finden ist. Diese Datei sorgt dafür, dass Liquibase das ChangeSet findet.
\begin{lstlisting}
<?xml version="1.0" encoding="UTF-8"?>   
<databaseChangeLog
xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xmlns:pro="http://www.liquibase.org/xml/ns/pro"
xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog
http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-4.23.xsd
http://www.liquibase.org/xml/ns/pro 
http://www.liquibase.org/xml/ns/pro/liquibase-pro-4.23.xsd">  
<includeAll path="db/versions"/>  
</databaseChangeLog>
\end{lstlisting}
	\section*{\small \textbf{3. Changelog Konfiguration - output-changelog.xml}}
	Diese Datei enthält sämtliche Datenbankänderungen und die Änderungen werden in Form von ChangeSet beschrieben und verwaltet.Im Folgenden ist ein Abschnitt im XML-Format für das Anlagen einer Tabelle Abonnement wiedergegeben. \\ 
\begin{lstlisting}
<changeSet author="ng (generated)" id="1743435452264-1">
	<createTable tableName="abonnement">
	<column name="id" type="VARCHAR(32)">
	<constraints nullable="false" primaryKey="true" primaryKeyName="abonnementPK" />
	</column>
	<column name="description" type="TEXT" />
	<column name="label" type="VARCHAR(255)">
	<constraints nullable="false" />
	</column>
	<column name="base_url" type="VARCHAR(255)" />
	<column name="file_format" type="VARCHAR(255)" />
	<column name="end_datum" type="date" />
	<column name="location_id" type="VARCHAR(255)" />
	<column name="parameter" type="VARCHAR(255)" />
	<column name="start_datum" type="date" />
	<column name="sub_url" type="VARCHAR(255)" />
	</createTable>
</changeSet>
\end{lstlisting}
	\section*{\small \textbf{4. Changelog Konfiguration - liquibase-new-diff-changelog.xml}}
	Diese Datei enthält nur bestimmte Änderungen von bestimmten Tabellen, die man in die Datei \texttt{output-changelog.xml} einfügt, wenn man das Schema der Datenbank modifiziert. Ähnlich wie in \texttt{output-changelog.xml} werden Änderungen auch in Form von ChangeSet beschrieben.
	
	\section{Datenbankmanagementsystem}
	Wie bereits in dem letzten Abschnitt offengelegt, wird ein PostgreSQL als das Datenbankmanagementsystem gewählt. 
	Da alle Datenbanken von Ahu GmbH zentral im lokalen Netzwerk liegen und die meisten Projekte PostgreSQL-Datenbank verwenden, ist es deswegen ersichtlich, dass für dieses Projekt auch eine PostgreSQL-Datenbank verwendet wird. \\
	Außerdem spricht der Einsatz einer PostgreSQL-Datenbank aufgrund ihrer zahlreichen Vorteile für sich.
	\begin{enumerate}
		\item Open-Source: geringe Kosten und hohe Flexibilität und Innovation, die bei anderen Datenbanklösung nicht immer möglich sind. 
		\item Leistung und Skalierbarkeit : PostgreSQL unterstützt eine Vielzahl von Leistungsoptimierung und verfügt über eine hohe Lese-/Schreibgeschwindigkeit, insbesondere bei der Unterstützung von Geodaten.
		\item Fundierte Sprachunterstützung : Aufgrund seiner Kompatibilität und Unterstützung mehrerer Programmiersprachen ist PostgreSQL eine der flexibelsten Datenbanken für Entwickler. Python, JavaScript, C/C++, Java und weitere beliebte Programmiersprachen bieten ausgereifte Unterstützung für PostgreSQL.
	\end{enumerate}
	
	\chapter{Anforderungsanalyse und Spezifikation }
	\section{Analyse}
	Während der Analysephase werden die \textbf{\textit{Stakeholder}} identifiziert und deren Anforderungen mittels \textbf{\textit{User Stories}} gesammelt. Die Anforderungen können in drei verschiedenen Untergruppen eingeteilt werden, um die systematisch und spezifisch behandeln zu können.
	\begin{enumerate}
		\item Funktionale Anforderungen beschreiben die Funktionen, die eine ganze Anwendung oder auch nur eine von ihren Komponenten erfüllen soll. Eine Funktion besteht aus drei Schritten: Eingabe der Daten-Systemverhalten-Ausgabe der Daten. Sie kann die Daten berechnen und manipulieren, Geschäftsprozesse ausführen, Benutzerinteraktionen herstellen oder andere Aufgabe ausführen.
		\item Nicht-funktionale Anforderungen beschreiben, wie das System es tut, während die funktionalen Anforderungen bestimmen, was das System tut. Darunter zählen die Leistungsstandards und Qualitätsmerkmale von Software, z.B. die Benutzerfreundlichkeit, Effektivität, Sicherheit, Skalierbarkeit usw.
		\item Randbedingungen sind Vorgaben, die den Lösungsraum einschränken und das Verhalten der Software beeinflussen.
	\end{enumerate}
	\subsection{Anwendungsszenario}
	Die zu entwickelnde Applikation soll als zentrale Plattform zur Suche, Verwaltung und Bereitstellung von Geodaten dienen. Sie ermöglicht die Aggregation relevanter Informationen aus verschiedenen Datenquellen und stellt diese über eine standardisierte Schnittstelle einem externen Client - wie dem \textbf{ahuManager} - zur Verfügung.
	\subsection{Stakeholder und User-Stories}
	In der Softwareentwicklung bezeichnet der Begriff Stakeholder alle Personen, Gruppen oder Organisationen, die ein Interesse am Erfolg eines Projekts haben und direkt oder indirekt von dessen Ergebnissen betroffen sind. Um die funktionalen Anforderungen dieser Stakeholder zu erfassen, werden sogenannte User-Stories verwendet. Diese beschreiben aus Sicht der Endnutzer konkrete Anwendungsbedarfe.
	\section*{\small \textbf{User-Stories:}}
	\begin{enumerate}
		\item Als Benutzer möchte ich in der Web-Oberfläche eine Übersicht über populäre Datenquellen erhalten, die relevante Geodaten bereitstellen.
		\item Als Benutzer möchte ich gezielt nach Messdaten wie Grundwasserständen, Pegelständen, Niederschlag, etc. recherchieren und dabei Informationen über das Datenformat und wesentliche Inhalte der Datensätze erhalten.
		\item Als Benutzer möchte ich Messdaten, die meist im CSV-Format oder individuell strukturierte ASCII-Dateien vorliegen,automatisiert in ein einheitliches Zielformat konvertieren lassen.
		\item Als Benutzer möchte ich die Daten in Form einer Gitter angezeigt bekommen.
		\item Als Als Benutzer möchte ich die Möglichkeit haben, bestimmte Datensätze zu abonnieren.
		\item Als Benutzer möchte ich die gefundenen Messdaten visuell auf einer Karte darstellen lassen.
	\end{enumerate}
	
	\section{Spezifikation}
	Basierend auf den im vorherigen Abschnitt formulierten User-Stories lassen sich die funktionalen Anforderungen der Anwendung konkretisieren. In diesem Zusammenhang werden zentrale \textbf{ Use-Cases} definiert, welche die Interaktionen zwischen Nutzern und dem System aus funktionaler Sicht beschreiben.
	\subsection{Use-Cases}
	Ein \textbf{Use-Case} beschreibt die sichtbare Interaktion eines Nutzers(Akteurs) mit dem System. Dabei kann es sich beim Akteur um eine Person,eine Organisation oder auch ein externes System handeln. Im Folgenden werden mehrere Use-Cases für die prototypische Anwendung dargestellt.
	\section*{\small \textbf{Use-Case 1:  Einsicht historischer \href{https://wetterdienst.readthedocs.io/en/latest/} {Wetterdaten}}}
	Akteur : Benutzer\\
	Ziel: Einsicht von Wetterdaten einer bestimmten Messstation\\
	Vorbedingung: keine\\
	Nachbedingung: Die Daten der ausgewählten Station wurden als Diagramm angezeigt\\
	\underline{Ablaufbeschreibung}:
	\begin{enumerate}
		\item Der Benutzer navigiert zur Ansicht „Historische Wetterdaten“.
		\item Die Seite zeigt initial eine leere Karte sowie verschiedene Dropdown-Menüs zur Auswahl der Datenparameter.
		\item Der Benutzer wählt eine gewünschte zeitliche Auflösung (z.B. stündlich, täglich, monatlich, jährlich).
		\item Daraufhin wird ein Dropdown-Menü mit Hauptparametern (z.B. Temperatur, Niederschlag) eingeblendet
		\item Nach Auswahl eines Hauptparameters erscheint ein weiteres Dropdown-Menü mit dazugehörigen Unterparametern.
		\item Das System zeigt anschließend eine Deutschlandkarte mit allen Messstationen, die den gewählten Unterparameter liefern. 
		\item Optional kann der Benutzer die Auswahl weiter eingrenzen – entweder auf ein bestimmtes Bundesland oder auf eine konkrete Messstation.
		\item Nach Auswahl einer Station wird diese auf der Karte fokussiert und die zugehörigen Wetterdaten in einem Diagramm visualisiert. 
	\end{enumerate}
	\section*{\small \textbf{Use-Case 2: Einsicht von \href{https://wetterdienst.readthedocs.io/en/latest/} {Wettervorhersagedaten}}}
	Akteur : Benutzer\\
	Ziel:  Einsicht von Wettervorhersagedaten einer bestimmten Messstation\\
	Vorbedingung: keine\\
	Nachbedingung: Die Vorhersagedaten wurden als Diagramm angezeigt\\
	\underline{Ablaufbeschreibung}:
	\begin{enumerate}
		\item Der Benutzer navigiert zur Ansicht „Wettervorhersage“.
		\item Die Seite zeigt eine Tabelle mit verschiedenen Parametern zur Anzeige verfügbarer Wetterdaten.
		\item Der Benutzer wählt eine Wetterstation aus einem Dropdown-Menü aus.
		\item Nach der Auswahl erscheint ein Button zur Überprüfung der Datenverfügbarkeit.
		\item Der Benutzer klickt auf den Button und wartet auf eine Rückmeldung des Systems.
		\item Das System prüft für alle Parameter in der Tabelle, ob jeweils Daten vorhanden sind.
		\item Basierend auf dem Ergebnis ergänzt das System die Tabelle um eine zusätzliche Spalte zur Einsicht verfügbarer Daten.
		\item er Benutzer klickt auf das angezeigte Symbol in der neuen Spalte.
		\item Ein Dialogfenster öffnet sich und visualisiert die Vorhersagedaten in Form eines Diagramms. 
	\end{enumerate}
	\section*{\small \textbf{Use-Case 3: Einsicht von Pegelstanddaten  (\href{https://www.pegelonline.wsv.de/gast/start} {PegelOnline})}}
	Akteur : Benutzer\\
	Ziel:  Einsicht von Pegelstanddaten einer ausgewählten Messstation\\
	Vorbedingung: keine\\
	Nachbedingung: Daten der gewählten Station werden visualisiert.\\
	\underline{Ablaufbeschreibung}:
	\begin{enumerate}
		\item Der Benutzer navigiert zur Ansicht „Pegelstanddaten“.
		\item Auf der linken Seite befinden sich Filteroptionen, auf der rechten Seite eine interaktive Karte mit deutschlandweiten Pegelstationen, farblich codiert nach aktuellem Pegelstatus.
		\item Der Benutzer wählt eine Station aus dem Filter „Pegelstation“.
		\item Das System zeigt – sofern verfügbar – historische sowie Vorhersagedaten der gewählten Station in einem Diagramm an.
	\end{enumerate}
	\section*{\small \textbf{Use-Case 4: Einsicht von Liste der Messstellen eines Klimaphänomen}}
	Akteur : Benutzer\\
	Ziel: Einsicht der Liste der Messstelle eines Klimaphänomen\\
	Vorbedingung: keine\\
	Nachbedingung: Die Messdaten zur gewählten Station und zum Phänomen werden angezeigt\\
	\underline{Ablaufbeschreibung}:
	\begin{enumerate}
		\item Der Benutzer navigiert zur zentralen Suchansicht.
		\item Es wird ein zentrales Eingabefeld angezeigt, in das ein Klimaphänomen eingegeben werden kann (in dieser Entwicklungsphase sind die möglichen Begriffe vorgegeben).
		\item Unabhängig vom eingegebenen Begriff erscheint links eine tabellarische Liste relevanter Messstellen aus verschiedenen Datenquellen; rechts wird eine Karte mit zugehörigen Messstellen angezeigt.
		\item Der Benutzer filtert die angezeigten Messstationen optional nach Koordinaten oder nach Datenanbieter.
		\item In der Tabelle befindet sich eine Spalte mit einem Button „Daten anzeigen“. Der Benutzer klickt darauf.
		\item Ein Dialogfenster öffnet sich, in dem ein Dropdown-Menü zur Auswahl spezifischer Datenoptionen erscheint.
		\item Nach Auswahl eines Eintrags zeigt das System die tatsächlichen Messdaten zur ausgewählten Station und zum gewählten Klimaphänomen.
	\end{enumerate}
	
	\section*{\small \textbf{Use-Case 5: Daten zu einem Klimaphänomen abonnieren}}
	Akteur : Benutzer\\
	Ziel: Die Daten einer ausgewählten Station zu einem Klimaphänomen abonnieren\\
	Vorbedingung: keine\\
	Nachbedingung: Die Daten einer ausgewählten Station wurde erfolgreich abonniert.\\
	\underline{Ablaufbeschreibung}:
	\begin{enumerate}
		\item Im geöffneten Dialogfenster befindet sich ein Button „Abonnieren“.
		\item Der Benutzer klickt auf den Button, woraufhin sich ein weiteres Dialogfenster öffnet.
		\item In diesem Dialog überprüft der Benutzer die Metadaten der zu abonnierenden Daten, kann ein Start- und Enddatum festlegen sowie das gewünschte Datenformat auswählen.
		\item Der Benutzer klickt auf den Button „Speichern“. Das Dialogfenster schließt sich automatisch.
		\item Anschließend wechselt der Benutzer zur Ansicht „Abonnement-Verwaltung“ und sieht den neu erstellten Abonnement-Eintrag in einer tabellarischen Übersicht.
	\end{enumerate}
	
\section*{\small \textbf{Use-Case 6: Abonnierte Datensätze in Grid abrufen}}
Akteur : Benutzer\\
Ziel: Abruf abonnierter Datensätze\\
Vorbedingung: Abonnements sind vorhanden.\\
Nachbedingung: Die abonnierten Daten wurden erfolgreich angezeigt.\\
\underline{Ablaufbeschreibung}:
\begin{enumerate}
	\item Der Benutzer navigiert zur Ansicht „Abonnement-Verwaltung“.
	\item In der rechten Spalte der Grid-Ansicht fährt er mit der Maus über ein Symbol mit dem Tooltip „Abonnierte Daten abrufen“ und klickt drauf.
	\item Ein Dialogfenster öffnet sich und bietet zwei Optionen zur Auswahl: „Alle Daten im angegebenen Zeitraum“ und „Inkrementelle Updates“
	\item Der Benutzer wählt die Option „Alle Daten im angegebenen Zeitraum“ aus.
	\item Das System leitet den Benutzer auf eine separate URL weiter, auf der die abonnierten Datensätze im gewählten Format angezeigt werden.
\end{enumerate}

\section*{\small \textbf{Use-Case 7: Umformatierung der Rohdaten konfigurieren}}
Akteur : Benutzer\\
Ziel:  Konfiguration der Umformatierung von Rohdaten\\
Vorbedingung: Rohdaten sind verfügbar.\\
Nachbedingung: Die Umformatierungskonfiguration wurde gespeichert.\\
\underline{Ablaufbeschreibung}:
\begin{enumerate}
	\item Der Benutzer klickt in der Grid-Ansicht zur Such-Ansicht auf den Button „Daten anzeigen“.
	\item Es öffnet sich ein Dialogfenster, das eine tabellarische Darstellung der Rohdaten sowie die Buttons „Abonnieren“ und „Umformatieren“ enthält. Der Benutzer klickt auf den Button „Umformatieren“.
	\item Ein neues Dialogfenster erscheint, in dem der Benutzer Parameter zur Umformatierung der Rohdaten anpassen kann (z.B. Feldtrennung, Strukturierung, Einheiten).
	\item Nach der Konfiguration klickt der Benutzer auf „Konfiguration speichern“.
	\item Das System speichert die Einstellungen persistent zur späteren Wiederverwendung.
\end{enumerate}
	
\chapter{Konzeption und Architektur}
\section{Konzeption}
Zur strukturierten Beschreibung der Systemarchitektur werden verschiedene Sichten eingesetzt. Diese ermöglichen es, das System aus unterschiedlichen Perspektiven zu betrachten und somit sowohl fachliche als auch technische Anforderungen klar und nachvollziehbar zu adressieren. Im Rahmen dieser Arbeit werden vier wesentliche Architektursichten betrachtet.

\section*{\large \textbf{1. Kontextsicht}}
Die Kontextsicht zeigt das zu entwickelnde System als Blockbox, mit dem die Interaktion des Users stattfindet und welche weiteren Systeme beteiligt sind, aus den das zu entwickelnde System Daten importieren or exportieren kann.\\
Die Abbildung 4.1 zeigt das System, welche sowohl die Schnittstelle zum Benutzer  also auch mit anderen externen System zum Importieren der Daten darstellt. Daraus hinaus ist es mit einem Datenbankmanagementsystem zur Speicherung von Daten verbunden.
\begin{figure}[H]
	\centering
	\includegraphics[width=12cm]{Kontextangrenzung.png}
	\caption{\label{} Kontextangrenzung}
\end{figure}
\clearpage
\section*{\large \textbf{2. Bausteinschicht}}
Die Bausteinschicht zeigt den näheren Aufbau des Systems - und zwar denjenigen Teil, den entwickelt wird. Jedes mit blau gefüllte Package beinhaltet alle Entitäten und die für den Aufbau der View und Datenaustausch mit der externen Datenquelle benötigten Komponenten.\\
Im Package \textbf{MainView} wird die Anwendung mit Startseite initialisiert und die Anbindung der weitern Views an die Hauptview ermöglicht. Das Package \textbf{Utils} beinhaltet zahlreiche Hilfsfunktionen. Diese dienen vor allem dazu, die Modularität, die Wartbarkeit und die Verständlichkeit des Codes sicherzustellen. Das Package \textbf{Konfiguration} beinhaltet unterschiedliche Konfigurationsklassen für die Applikation.\\ Die anderen Packages sind gemäß dem Single Responsibility Principle (SRP) aufgebaut. Jedes Package verfolgt dabei eine klar definierte, spezifische Aufgabe. Durch die Anwendung des SRP werden die Verantwortlichkeiten innerhalb des Systems präzise getrennt, was die Projektstruktur übersichtlicher und verständlicher macht.
\begin{figure}[H]
	\centering
	\includegraphics[width=15cm]{Bausteinsicht-1.png}
	\caption{\label{} Bausteinsicht}
\end{figure}
\clearpage
\section*{\large \textbf{3. Laufzeitsicht}}
Die Laufzeitsicht beschreibt, wie ein System während seiner Ausführung seine wesentliche Aufgaben ausführt. Häufig werden Sequenzdiagramme verwendet, um die Laufzeitsicht zu visualisieren,insbesondere zur Darstellung von Interaktionen zwischen Systemteilen.
\begin{figure}[H]
	\includegraphics[width=18.5cm]{Such-Algorithmus.png}
	\caption{\label{} Use-Case 4: Einsicht der Liste der Messstelle eines Klimaphänomen}
\end{figure}
Die obige Abbildung demonstriert das Use-Case 4 basierend auf die Nutzer-Eingabe. Ein Benutzer gibt einen Suchbegriff in ein Suchfeld ein. Daraufhin wird:  
\begin{enumerate}
	\item Der Begriff ins Englische übersetzt,da die Anfrage an den Server ausschließlich mit englischen Parametern zulässt,um passende Wetterstation über den Deutschen Wetterdienst zu finden (historisch und prognostisch).
	\item Bei passenden Begriffen wie „Pegel“ oder „Grundwasser“ werden zusätzliche Datenquellen abgefragt:
	\begin{itemize}
		\item Pegelstationen über den Pegeldienst
		\item Grundwasser - oder Oberflächendaten über einen Web-Crawler((CrawlerFileService)), der OpenGeoData-Dateien herunterlädt und filtert.
	\end{itemize}
	\item Die gefundenen Dateien werden entpackt und analysiert, um Stationsdaten zu extrahieren. Alle Stationen werden zusammengeführt, nach Anbieter gruppiert und dem Benutzer im UI (Gitteransicht + Kartenansicht + Filtermöglichkeiten) dargestellt.
\end{enumerate}
\begin{figure}[H]
	\includegraphics[width=18.5cm]{CsvKonfiguration.png}
	\caption{\label{} Use-Case 7: Umformatierung der Rohdaten konfigurieren}
\end{figure}
Die Abbildung 4.4 illustriert den Fluss vom Use-Case 7. Ein Benutzer wählt eine CSV-Datei aus einer Dropdown-Liste aus und klickt auf „Umformatieren". Das System:
\begin{enumerate}
	\item Ermittelt die passende Konfiguration (falls vorhanden) basierend auf dem Dateinamen.
	\item Lädt die zugehörige Datei aus bereits extrahierten Dateien.
	\item Erzeugt eine neue Zuordnungstabelle (Grid), in der die Spalten der CSV-Datei angezeigt werden.
	\item Benutzer kann dann:
		\begin{itemize}
			\item Quell-und Zielspalten manuell zuordnen.
			\item Feste Werte für eine Spalte eintragen.
			\item Einträge als Header löschen oder bearbeiten.
		\end{itemize}
	\item Diese Konfiguration kann anschließend gespeichert oder für die weitere Verarbeitung verwendet werden.
\end{enumerate}
\section*{\large \textbf{4. Verteilungsschicht}}
Üblicherweise beschreibt die Verteilungssicht die technische Infrastruktur und wie sich die einzelnen (Software-)Bausteine auf die einzelnen Infrastrukturkomponenten verteilen.\\ \\
Im Rahmen dieses Prototyps wird auf die Verteilungsschicht verzichtet, da die entwickelte Anwendung ausschließlich lokal (auf dem \textit{localhost}) ausgeführt wird und kein Deployment auf verteilte Systemumgebungen vorgesehen ist. Eine detaillierte Beschreibung der physischen Infrastruktur ist daher zum aktuellen Zeitpunkt nicht erforderlich.

\clearpage
\section{Design-Entscheidung}
Bei der Architekturarbeit geht es meistens darum, die Entscheidungen zu treffen,die dazu beitragen, konkrete Lösungen für die aktuellen Herausforderungen zu finden. Von daher kommen zunächst zwei Architekturstile bei dieser prototypischen Entwicklung in Frage: \textbf{Monolith} und \textbf{Event-Driven Architektur}( Ereignisgesteuerte Architektur).\\ \\
Bei der \textbf{monolithischen Architektur}  handelt es sich um eine Softwarearchitektur, bei der alle Funktionalitäten und Komponenten einer Anwendung in einem einzigen, zusammenhängenden Codeblock gebündelt sind. Die gesamte Anwendung wird gemeinsame entwickelt, getestet, bereitgestellt und skaliert. Monolithen sind oft einfacher zu konfigurieren und zu verwalten, insbesondere in der frühen Phase eines Projekts. \\ \\
Im Gegensatz dazu basiert die \textbf{Event-Driven Architektur} auf dem Prinzip, dass Komponenten lose gekoppelt sind und über Ereignisse miteinander kommunizieren. Jede Komponente reagiert auf bestimmte Ereignisse und löst ggf. weitere Ereignisse aus.Diese Architektur eignet sich besonders gut für Systeme mit hoher Skalierbarkeit, Flexibilität  und dynamischen Anforderung, ist jedoch oft komplexer in der Aufstellung der Infrastruktur und im Betrieb.\\ \\
Für die prototypische Entwicklung habe ich mich für die \textbf{monolithische Architektur} entschieden, da sie einen schnelleren Entwicklungsstart ermöglicht, weniger Infrastruktur erfordert und die Komplexität im Vergleich zur \textbf{Event-Driven-Architektur} zunächst gering ist. Diese Entscheidung erlaubt es, mehr den Fokus auf die Umsetzungen der Kernfunktionalitäten zu legen, ohne sich frühzeitig mit verteilten Systemen oder asynchroner Kommunikation auseinandersetzten zu müssen. 
	
	
\chapter{Implementierung}
In diesem Kapitel wird über die Implementierung einzelner wichtiger Komponenten für die zuvor gewählte Architektur berichtet und ebenfalls auf während der Umsetzung auftretende Schwierigkeiten eingegangen. 
\section{Übersicht über wichtige Klassen und Entitäten}
Wie bereits am Anfang des 2.Kapitels erwähnt, wird als Einstiegspunkt für die Entwicklung eine Vaadin Applikation durch Bereitstellung von Vaadin Initializer genommen. Dies Package enthält die grundlegenden Komponente für eine simple Benutzeroberfläche. 
	
In diesem Package gibt es eine kurz Main-Klasse(\textbf{Application.java}) als Startpunkt für die Applikation, die folgenden Aufbau hat: \\
\begin{lstlisting}
@SpringBootApplication
@Theme(value = "opendata-konnektor")
@EnableCaching
public class Application implements AppShellConfigurator {
	public static void main(String[] args) {
		SpringApplication.run(Application.class, args);
	}
}
\end{lstlisting}
	Die Annotation \textbf{@SpringBootApplication} kombiniert aus:
		\begin{enumerate}
			\item  \textbf{@Configuration}: markiert die Klasse als Konfigurationsklasse für Spring.
			\item  \textbf{@EnableAutoConfiguration}: ermöglicht die automatische Konfiguration basierend auf den Abhängigkeiten im Klassenpfad.
			\item  \textbf{@ComponentScan}: sucht nach Komponenten, Konfigurationsklassen und Services im aktuellen Pakte und allen Unterpakten.
		\end{enumerate}
	Die Annotation \textbf{@Theme(value = "opendata-konnektor")} legt das Vaadin-Theme fest. \textbf{value} definiert den Namen des Themes und Themens werden verwendet, um das Erscheinungsbild der Anwendung anzupassen.\\
	Die Annotation \textbf{@EnableCaching} aktiviert die Spring Caching-Funktionalität und ermöglicht die Verwendung von Cache-Mechanismen(\textbf{@Cacheable},\textbf{@Cacheable},\textbf{@CacheEvict}).\\
	\textbf{AppShellConfigurator} ist eine Schnittstelle (\textbf{Interface}) aus dem Vaadin Framework. Sie wird verwende, um die \textbf{App Shell} einer Vaadin-Anwendung zu konfigurieren. Was ist die App Shell in Vaadin ?
	\begin{itemize}
		\item Die App Shell is ein grundlegendes HTML-Dokument, das vom Server an den Client gesendet wird.
		\item Es enthält die wesentlichen Informationen wie Meta-Tags, Icons, Stylesheets usw., die bei der ersten Anfrage geladen werden.
		\item Die App Shell bleibt auch unverändert, während der Inhalt dynamisch aktualisiert wird.
	\end{itemize}
	
	Um jedes Object oder jede Entität möglichst spezifisch zu halten, wird am Anfang eine grundlegende, nicht abgeleitete Basisentität, die als Vorlage oder Basis dient, auf der andere Entitäten aufgebaut werden können, indem sie deren Eigenschaften erben, ohne diese erneut zu definieren.In Java-Programmiersprache wird dieses Verhalten als \textbf{Vererbung} bezeichnet. Als Beispiel wird die Klasse \textbf{„BaseEntity“}  erläutert:
\begin{lstlisting}
@MappedSuperclass
@Getter
@Setter
public class BaseEntity implements Comparable<BaseEntity> {
	@Id
	@GeneratedValue(generator = "generateIfNotAssigned")
	@GenericGenerator(name = "generateIfNotAssigned", strategy = "org.hibernate.id.UUIDHexGenerator")
	@Column(length = 32)
	@Access(jakarta.persistence.AccessType.PROPERTY)
	private String id;
			
	@Length(min = 1)
	@NotNull
	private String label;
			
	@Column(columnDefinition = "TEXT")
	private String description;
			
	@Column(name = "base_url")
	private String url;
			
	@Column(name = "last_updated")
	private LocalDate lastUpdated;
			
	public int compareTo(BaseEntity o) {
		return (id != null) ? id.compareTo(o.getId()) : hashCode() - o.hashCode();
	}
	@Override
	public int hashCode() {
		return (id != null) ? id.hashCode() : 1;
	}
	@Override
	public boolean equals(Object obj) {
		if (!(obj instanceof BaseEntity)) {
			return false;
		}
		BaseEntity be = (BaseEntity) obj;
		return (id != null) ? id.equals(be.getId()) : this == be;
	}
}	
\end{lstlisting}
	Die Annotation \textbf{@MappedSuperclass} kennzeichnet die Klasse als Basisklasse für andere JPA-Entitäten. Die Felder und Methoden dieser Klasse werden nicht direkt in der Datenbank abgebildet, sondern in die Tabellen der abgeleiteten Klassen integriert.Außerdem wird es verwendet, um gemeinsame Eigenschaften (\textbf{id, label}), etc. zentral zu definieren.\\ \\
	Die Annotation \textbf{@Getter} und \textbf{@Setter} sind Lombok Annotation, die automatisch Getter/Setter-Methoden für alle Felder der Klasse generiert.\\
	Die Annotation \textbf{@Id} ist ein JPA-Annotation und kennzeichnet das Primärschlüsselfeld der Entität.\\ \\
	Die Annotation \textbf{@GeneratedValue(generator = "generateIfNotAssigned")} ist ebenfalls ein JPA-Annotation und gibt an, dass der Wert für \textbf{id} automatisch generiert wird. Die Option \textbf{generator} verweist auf einen benutzerdefinierten Generator.\\ \\
	Die Annotation \textbf{@GenericGenerator)} ist eine Hibernate-spezifische Annotation und definiert einen benutzerdefinierten ID-Generator. Die Option \textbf{name} ist der Name des Generators, hier „generateIfNotAssigned". Die Option \textbf{strategy} ist die Strategie für die ID-Erzeugung, und \textbf{UUIDHexGenerator} generiert UUIDs als Hex-Strings(32 Zeichen).\\ \\
	Die Annotation \textbf{@Access(jakarta.persistence.AccessType.PROPERTY)} definiert, wie auf Felder/Methoden zugegriffen wird. In diesem Fall erfolgt der Zugriff mit \textbf{PROPERTY} über Getter und Setter-Methoden. \\ \\
	Die Annotation \textbf{@Length(min = 1)} ist eine Hibernate-Validator Annotation und legt die minimale Länge für das Feld auf 1 Zeichen fest.\\
	Die Annotation \textbf{@NotNull} ist ein Bean Validation Annotation und verhinder, dass \textbf{label} auf \textbf{null} gesetzt wird und immer einen Wert haben muss.\\
	Die Annotation \textbf{@Column(columnDefinition = "TEXT")} ist JPA Annotation und definiert die Datenbankspalte \textbf{description} als \textbf{TEXT} und \textbf{TEXT} erlaubt lange Zeichenketten (mehr als \textbf{VARACHAR}). 
\begin{lstlisting}
	implements Comparable<BaseEntity>
\end{lstlisting} Damit kann die Klasse verglichen und sortiert werden, basierend auf der \textbf{id}  in der Methode \textbf{compareTo}.
	Die Annotation \textbf{@Override} stellt sicher, dass die Methode die korrekte Signatur aus dem \textbf{Comparable} Interface hat. \\ \\
	Um die Verwendung der obigen beschriebenen Klasse zu veranschaulichen, wird als Beispiel die Klasse \textbf{„Abonnement“}  erläutert:
\begin{lstlisting}
@Entity
@Table(name = "abonnement")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class Abonnement extends BaseEntity {
	@Column(name = "file_format")
	private String dateiFormat;
	private String parameter;
	@Column(name = "location_id")
	private String locationId;
	@Column(name = "start_datum")
	private LocalDate startDatum;
	@Column(name = "end_datum")
	private LocalDate endDatum;
	@Column(name = "sub_url")
	private String subscriptionUrl;
}
\end{lstlisting}
	Die Klasse \textbf{Abonnement} erbt von der Basisklasse \textbf{BaseEntity}. Dadurch übernimmt sie automatisch alle Eigenschaften (\textbf{id,label,description,url,etc.}) und Methoden(\textbf{compareTo, hashCode, equals}) der Basisklasse.\\
	Die Annotation \textbf{@Enity} markiert die Klasse als JPA-Entität und wird in der Datenbank als Tabelle gespeichert. Die Annotation \textbf{@NoArgsConstructor} (Lombok) generiert einen parameterlosen Konstruktor und \textbf{@AllArgsConstructor} hingegen einen Konstruktor mit allen Feldern als Parameter.\\ \\
	Anschließend an die Entität, wird das zugehörige Repository, in Form eines Interfaces implementiert. Es erweitert \textbf{JpaRepository}, wodurch eine Vielzahl von CRUD-Operationen und zusätzlichen Methoden bereitgestellt werden.
\begin{lstlisting}
@Repository
public interface AbonnementRepository extends JpaRepository<Abonnement, String>{}
\end{lstlisting}
	Die Annotation \textbf{@Repository} kennzeichnet die Schnittstelle als Datenbank-Repository und wird von Spring verwendet, um die Klasse als Datenzugriffsschicht zu erkennen und ermöglicht die automatische Fehlerbehandlung bei Datenbankoperationen.\\
	\textbf{JpaRepository$<$T, ID$>$} ist eine generische Schnittstelle, die CRUD-Methoden bereitstellt:
	\begin{itemize}
		\item T : die Entitätsklasse, die verwaltet wird, in diesem Fall(Abonnement).
		\item Id: der Datentyp des Primärschlüssels (String).
	\end{itemize}
	Für die Entität \textbf{Abonnement} wird ein sogenannten AbonnementController bereitgestellt, mit dem der Zugriff auf die Daten von außen ermöglicht.
\begin{lstlisting}
@RestController
@RequestMapping("/api/subscription")
public class AbonnementController {
	@Autowired
	private AbonnementService abonnementService;
			
	@GetMapping(value = "/data")
	public ResponseEntity<String> getAboData(@RequestParam @NotBlank String id) {
		return abonnementService.fetchAbonnementData(id).orElseGet(() -> ResponseEntity.status(HttpStatus.NOT_FOUND).body("kein Abonnement fuer die " + id + "gefunden.))
	}
	@GetMapping(value = "/incremental_data")
	public ResponseEntity<String> getIncrementalData(@RequestParam @NotBlank String id) {
		return abonnementService.fetchInrementalData(id).orElseGet(
		() -> ResponseEntity.status(HttpStatus.NOT_FOUND).body("Kein Abonnement fuer die " + id + " gefunden."));
	}
}
\end{lstlisting}
Die Annotation \textbf{@RestController} ist eine Kombination aus \textbf{@Controller} und \textbf{@ResponseBody} und markiert diese Klasse als REST-Controlle und die Methodenrückgaben werden automatisch in HTTP-Responses konvertiert.\\ \\
Die Annotation \textbf{@RequestMapping(/api/subscription)} definiert den Basis-URL-Pfad für alle Endpunkte in dieser Klasse.
Mit der Annotation \textbf{@Autowired} sucht Spring automatisch nach einer passenden Bean und injiziert diese in das Controller-Feld \textbf{abonnementService}. Dies ist in Spring als \textbf{Dependency Injection} genannt.\\ \\
Die Annotation \textbf{@GetMapping(/data)} definiert einen GET-Endpunkt unter /api/subscription/data und \textbf{@RequestParam} extrahiert den \textbf{id}-Parameter aus der URL-Abfragezeichenkette. \textbf{@NotBlank} ist ein Bean Validation und validiert, dass der \textbf{id}-Parameter nicht leer ist und falls der leer ist, wird ein 400 Bad Request zurückgegeben. \textbf{ResponseEntity$<$String$>$} wird verwendet, um eine HTTP-Response mit einem StatusCode und einem Body zurückzugeben.
	
\section{Front-End-Komponente }
Im Rahmen dieses Abschnittes wird die Implementierung des Use-Cases 4: Einsicht von Liste der Messstellen eines Klimaphänomen erläutert. Die Entwicklung erfolgt unter Verwendung von Vaadin-Framework.\\ \\
Die Umsetzung eines UI-Komponents erfolgt unter Java-Programmiersprache als Klasse, welche ein Komponent wie z.B. ein VerticalLayout oder HorizontalLayout oder ein Dialog von Paket \textbf{com.vaadin.flow.component.Component} erbt.
\begin{lstlisting}
import com.vaadin.flow.component.combobox.ComboBox;
import com.vaadin.flow.component.orderedlayout.HorizontalLayout;
import com.vaadin.flow.component.orderedlayout.VerticalLayout;
		
@Route(value = "suche", layout = MainLayout.class)
@Slf4j
public class SearchGeoDataView extends VerticalLayout {
			
	private ComboBox<String> tfSearch = new ComboBox<>();
	tfSearch.setPlaceholder("Suche nach Phaenomen");
	tfSearch.setClearButtonVisible(true);
	List<String> phaenomenList = List.of("Niederschlag", "Grundwasser", "Pegel", "Bodentemperatur",
	"Lufttemperatur", "Luftfeuchtigkeit", "Windgeschwindigkeit", "Windrichtung", "Windstärke", "Windböe",
	"Sonnenscheindauer", "Gesamtbewölkung");
	tfSearch.setItems(phaenomenList.stream().sorted().toList());
	tfSearch.setAllowCustomValue(true);
	tfSearch.setWidth("20%");
	tfSearch.getStyle().set("borderRadius", "12px").set("padding", "0.5rem 1rem")
	.set("boxShadow", "0 2px 6px rgba(0, 0, 0, 0.1)").set("backgroundColor", "#fff");
		
	HorizontalLayout searchLayout = new HorizontalLayout(tfSearch);
	searchLayout.setWidthFull();
	searchLayout.setJustifyContentMode(JustifyContentMode.CENTER);
	add(searchLayout);
}
\end{lstlisting}
Mit dem obigen Code ergibt sich folgende Abbildung ohne die Navigationsleiste: 
\begin{figure}[h!]
	\centering
	\includegraphics[width=17cm]{suchSeite.png}
	\caption{\label{suche:Seite}Suche Seite}
\end{figure}
	
Wie üblich in Java, initialisiert man ein Komponente in Vaadin auch mit dem Schlüsselwort \textbf{new}. Bei dem Beispiel wird ein DropDown-Feld zur Auswahl von \textbf{String}-Werten erstellt.\\ \\
Mit Abruf von \textbf{tfSearch.getStyle()} wird dies Dropdown stilisiert und mit \textbf{tfSearch.setItems(...)} mit vordefinierten Phänomenen gefüllt. Mit \textbf{HorizontalLayout searchLayout = new HorizontalLayout(tfSearch)} wird ComboBox in ein \textbf{HorizontalLayout}  eingebettet und zentriert ausgerichtet.\\
Am Ende mit \textbf{add(searchLayout)} wird das Layout zur Benutzeroberfläche hinzugefügt.\\ \\
Zurück zu der Navigationsleiste, um so einen Leiste in Vaadin erstellen zu können, wird anhand des Code ins Details eingegangen.\\

Die Annotation \textbf{@Layout} wird verwendet, um die Klasse als Layout festzulegen. In Vaadin bestimmt ein Layout, wie der Seiteninhalt strukturiert wird, insbesondere wie Komponenten innerhalb des Layouts angeordnet werden.\\	

Die Annotation \textbf{@AnonymousAllowed} erlaubt es anonymen Benutzern (nicht authentifizierten Benutzern), auf dieses Layout zuzugreifen. Ohne diese Annotation wäre der Zugriff auf diese Klasse möglicherweise eingeschränkt.
\begin{lstlisting}
@Layout
@AnonymousAllowed
public class MainLayout extends AppLayout {
	public MainLayout() {
		addToNavbar(createHeaderContent());
	}
	private Component createHeaderContent() {
		Header header = new Header();
		header.addClassNames(BoxSizing.CONTENT, Display.FLEX, FlexDirection.COLUMN, Width.FULL);
				
		Nav navMain = new Nav();
		navMain.addClassNames(Display.FLEX, Overflow.AUTO, Padding.Horizontal.MEDIUM, Padding.Vertical.XSMALL,
		TextColor.PRIMARY, BoxShadow.MEDIUM, Width.FULL);
		UnorderedList navMainItemList = new UnorderedList();
		navMainItemList.addClassNames(Display.INLINE_FLEX, Gap.LARGE, ListStyleType.NONE, Margin.NONE, Padding.SMALL,
		TextColor.PRIMARY);
		navMain.add(navMainItemList);
				
		for (MenuItemInfo menuItem : createMainMenuItems()) {
			navMainItemList.add(menuItem);
		}
				
		HorizontalLayout navControls = new HorizontalLayout();
		navControls.setSpacing(false);
		navControls.setJustifyContentMode(FlexComponent.JustifyContentMode.BETWEEN);
		navControls.add(navMain);
		header.add(navControls);
		return header;
	}
			
	private MenuItemInfo[] createMainMenuItems() {
		return new MenuItemInfo[] { new MenuItemInfo(null, VaadinIcon.HOME.create(), StartView.class),
			new MenuItemInfo(null, VaadinIcon.SEARCH.create(), SearchGeoDataView.class),
			new MenuItemInfo("GovData-Das Datenportal", VaadinIcon.DATABASE.create(), GridGovData.class),
			new MenuItemInfo("OpenGeodata.NRW", VaadinIcon.MODAL_LIST.create(), OpenDataNrwView.class),
			new MenuItemInfo("Wettervorhersage", VaadinIcon.TABLE.create(), WettervorhersageView.class),
			new MenuItemInfo("Historische Wetterdaten", VaadinIcon.SPLINE_CHART.create(),
			HistoricalWetterDatenView.class),
			new MenuItemInfo("Pegelständedaten", VaadinIcon.DROP.create(), PegelstandView.class),
			new MenuItemInfo("Abonnement-Verwaltung", VaadinIcon.LINES_LIST.create(), GridAbonnement.class) };
	}
			
	public static class MenuItemInfo extends ListItem {
		private final Class<? extends Component> view;
		public MenuItemInfo(String menuTitle, Component icon, Class<? extends Component> view) {
			this.view = view;
			RouterLink link = new RouterLink();
			link.addClassNames(Display.FLEX, Gap.XSMALL, Height.MEDIUM, AlignItems.CENTER, Padding.Horizontal.SMALL,
			TextColor.BODY);
			link.setRoute(view);
			Span text = new Span(menuTitle);
			text.addClassNames(FontWeight.MEDIUM, FontSize.MEDIUM, Whitespace.NOWRAP);
					
			if (icon != null) {
				link.add(icon);
			}
			link.add(text);
			add(link);
		}
		public Class<?> getView() {
			return view;
		}
	}
}
\end{lstlisting}
Die Klasse \textbf{MainLayout} erweitert \textbf{AppLayout},welches in Vaadin ein standardisiertes Layout ist, das eine Navigationsleiste und einen Inhaltsbereich definiert. Im Konstruktor wird \textbf{createHeaderContent()} aufgerufen und zum Navigationsbereich (\textbf{Navbar}) hinzufügt.\\ 

Die Methode \textbf{createHeaderContent()} erstellt den Header-Bereich der Anwendung. Die Komponente \textbf{Header} wird erstellt und gestylt. Das Navigationselement mit \textbf{Nav} wird erstellt und eine \textbf{UnorderedList} wird hinzugefügt. Für jedes \textbf{MenuItemInfo} wird ein Listenelement \textbf{ListItem} hinzufügt. Der Header wird zurückgegeben und in die Navbar eingefügt.\\

Die Methode \textbf{createMainMenuItems()} erzeugt ein Array von \textbf{MenuItemInfo}- Objekten. Jedes \textbf{MenuItemInfo}- Objekte repräsentiert einen Menüpunkt mit einem Titel, einem Icon und einer zugehörigen View-Klasse. \\

Die innere Klasse \textbf{MenuItemInfo} erweitert \textbf{ListItem} und stellt ein Navigationsmenüelement dar. Konstruktor erstellt einen \textbf{RouterLink}, fügt optional Icon und den Text hinzu. Die Methode \textbf{getView()} gibt die View-Klasse zurück, die beim Klicken auf das Menüelement aufgerufen wird.
\clearpage
Wählt man nun einen Eintrag aus der DropDownList aus,z.B.\textbf{Pegel}, ergibt sich folgende Abbildung:
\begin{figure}[H]
	 \centering
	\includegraphics[width=18cm]{pegel.png}
	\caption{\label{pegel:}Einsicht von Liste der Pegelstation}
\end{figure}
Bei der Abbildung sind es drei Hauptkomponenten deutlich zu erkennen, nämlich : die Tabelle, die Karte und die Filtermöglichkeiten nach Koordinaten und Servicename.
\section*{\small \textbf{1. Die Tabelle}}
In Vaadin wird eine Tabelle als Grid genannt und wird in dem Code wie folgt initialisiert.
\begin{lstlisting}
private Grid<StationDTO> stationGrid = null;

private Grid.Column<StationDTO> nameColumn = null;
private Grid.Column<StationDTO> providerColumn = null;
private Grid.Column<StationDTO> historischColumn = null;
private Grid.Column<StationDTO> vorhersageColumn = null;
private Grid.Column<StationDTO> btnColumn = null;
private StationDTOFilter filter;
private HeaderRow headerRow = null;
private StationDTO currentStation = null;

private void initGridStation() {
	stationGrid = new Grid<>(StationDTO.class, false);
	dataProviderStations = stationGrid.setItems(mergedStations);
	
	nameColumn = stationGrid.addColumn(station -> station.getName()).setHeader("Name")
	.setAutoWidth(true).setFlexGrow(1);
	providerColumn = stationGrid.addColumn(station -> station.getProvider()).setHeader("Provider/Gebiet")
	.setAutoWidth(true).setResizable(true).setFlexGrow(1);
	historischColumn = stationGrid.addColumn(new ComponentRenderer<>(station -> {
		if (station instanceof WetterStationDTO wetter) {
			Icon statusIndicator = new Icon();
			if (wetter.getIsHistorical() != null && wetter.getIsHistorical()) {
				statusIndicator = VaadinIcon.CHECK_CIRCLE.create();
				statusIndicator.setColor("green");
				statusIndicator.addClassName("text-body");
				statusIndicator.setSize("1em");
			}
			return statusIndicator;
		}
		if (station instanceof PegelStationDTO pegel) {
			Icon statusIndicator = new Icon();
			if (pegel.getIsHistorical() != null && pegel.getIsHistorical()) {
				statusIndicator = VaadinIcon.CHECK_CIRCLE.create();
				statusIndicator.setColor("green");
				statusIndicator.addClassName("text-body");
				statusIndicator.setSize("1em");
			}
			return statusIndicator;
		}
		return null;
	})).setHeader("Historisch").setAutoWidth(true).setFlexGrow(0);
	
	vorhersageColumn = stationGrid.addColumn(new ComponentRenderer<>(station -> {
		if (station instanceof WetterStationDTO wetter) {
			Icon statusIndicator = new Icon();
			if (wetter.getIsForecast() != null && wetter.getIsForecast()) {
				statusIndicator = VaadinIcon.CHECK_CIRCLE.create();
				statusIndicator.setColor("blue");
				statusIndicator.addClassName("text-body");
				statusIndicator.setSize("1em");
			}
			return statusIndicator;
		}
		if (station instanceof PegelStationDTO pegel) {
			Icon statusIndicator = new Icon();
			if (pegel.getIsForecast() != null && pegel.getIsForecast()) {
				statusIndicator = VaadinIcon.CHECK_CIRCLE.create();
				statusIndicator.setColor("blue");
				statusIndicator.addClassName("text-body");
				statusIndicator.setSize("1em");
			}
			return statusIndicator;
		}
		return null;
	})).setHeader("Vorhersage").setAutoWidth(true).setFlexGrow(0);
	
btnColumn = stationGrid.addColumn(new ComponentRenderer<>(st -> {
	Button btnShowData = new Button("Daten anzeigen");
	btnShowData.addThemeVariants(ButtonVariant.LUMO_SMALL, ButtonVariant.LUMO_PRIMARY);
		
	btnShowData.addClickListener(click -> {
	if (dialogData == null) {
		dialogData = new Dialog();
	} else {
		dialogData.removeAll();
		dialogData = new Dialog();
	}
	....
	// Weitere Logik fuer die Datenverarbeitung
	});
	return btnShowData;
})).setAutoWidth(true).setFlexGrow(1);
	
stationGrid.setColumnOrder(nameColumn, providerColumn, historischColumn, vorhersageColumn, btnColumn);
stationGrid.setSizeFull();
	
stationGrid.getHeaderRows().clear();
headerRow = stationGrid.appendHeaderRow();
filter = new StationDTOFilter(dataProviderStations);
headerRow.getCell(nameColumn).setComponent(createFilterHeader(filter::setStationName));
headerRow.getCell(providerColumn).setComponent(createFilterHeader(filter::setProvider));
\end{lstlisting}

Bei dem Code-Abschnitt wird ein \textbf{Grid<StationDTO>} initialisiert und es erstellt fünf Spalten:
\begin{enumerate}
\item \textbf{Name} – Zeigt den Namen der Station an.
\item \textbf{Provider/Gebiet} – Zeigt den Anbieter oder das Gebiet der Station an.
\item \textbf{Historisch} – Zeigt ein grünes Icon an, wenn die Station historisch ist (getIsHistorical() ist true)
\item \textbf{Vorhersage} – Zeigt ein blaues Icon an, wenn Vorhersagedaten verfügbar sind (getIsForecast() ist true).
\item \textbf{Daten anzeigen} – Fügt einen Button hinzu, der beim Klicken ein Dialogfenster zur Datenanzeige öffnet.
\item Zusätzlich wird ein HeaderRow für die Filterung hinzugefügt, der Filter für Name und Provider ermöglicht.
\end{enumerate}


\section*{\small \textbf{2. Die Karte}}
Die Karte ist eine Komponente, die an vielen Stellen in der Applikation wiederverwendbar ist, deswegen ist es sinnvoll, diese als eine eigene Klasse auszulagern.\\
Die Methode zum Aufruf der Karte-Komponente:
\begin{lstlisting}
private void initOpenLayersMap() {
  if (!mapVerticalLayout.getChildren().anyMatch(component -> component instanceof OpenLayersMap)) {
	olMap = new OpenLayersMap();
	olMap.setSizeFull();
	olMap.showStationsOnMap(dataProviderStations.getItems()
	.collect(Collectors.toList()));
    mapVerticalLayout.add(olMap);
  } else {
	olMap.showStationsOnMap(dataProviderStations.getItems()
	.collect(Collectors.toList()));
  }
}
\end{lstlisting}
Die Methode \textbf{initOpenLayersMap()} initialisiert eine \textbf{OpenLayersMap}-Komponente in einem Vaadin-Layout :
\begin{itemize}
\item prüft, ob bereits eine \textbf{OpenLayersMap} im \textbf{mapVerticalLayout} vorhanden ist.
\item Falls nicht vorhanden, wird eine neue  \textbf{OpenLayersMap} erstellt und den Stationen aus dem  \textbf{dataProviderStations}-Datensatz hinzugefügt.
\item Falls bereits vorhanden, wird die bestehende Karte aktualisiert, um die Stationen anzuzeigen.
\item Ein \textbf{DataProvider} in Vaadin ist eine Datenquelle, die Daten für UI-Komponenten wie Grids bereitstellt. Es verwaltet die Daten und stellt Methoden zur Verfügung, um Daten zu filtern, zu sortieren und zu aktualisieren.
\end{itemize}

\begin{lstlisting}
@NpmPackage(value = "ol", version = "8.2.0")
@NpmPackage(value = "ol-ext", version = "4.0.13")
@NpmPackage(value = "ol-layerswitcher", version = "4.1.1")
@NpmPackage(value = "ol-popup", version = "5.1.0")
@Tag("openlayers")
@JsModule("./src/openlayers-connector.js")
@Slf4j
public class OpenLayersMap extends Div {
	public OpenLayersMap() {
		this.getParent().ifPresent(null);
		initConnector();
		addDetachListener(detach -> { shutDown();});
	}
	public <T extends RestDTO> void showStationsOnMap(List<T> stations) {
		runBeforeClientResponse(ui -> {
			boolean isWetterstation = false;
			if (stations != null && !stations.isEmpty()) {
				isWetterstation = stations.get(0) instanceof WetterStationDTO;
			}
			String jsArray = buildStationsJson(stations);
			ui.getPage()
			.executeJs("window.Vaadin.Flow.openLayersConnector.showStations($0, $1, $2)", getElement(),
			jsArray, isWetterstation);
		});
	}
	private <T extends RestDTO> String buildStationsJson(List<T> stations) {
		try {
			if (stations == null || stations.isEmpty()) {
				return "[]";
			}
			return objectMapper.writeValueAsString(stations);
		} catch (Exception e) {
			e.printStackTrace();
			return "[]";
		}
	}
	private void initConnector() {
		runBeforeClientResponse(ui -> ui.getPage()
		.executeJs("window.Vaadin.Flow.openLayersConnector.initLazy($0)", getElement()));
	}
}
\end{lstlisting}

Die Klasse \textbf{OpenLayersMap} erweitert Div und integriert eine  \textbf{OpenLayers}-Kartenkomponente.\\
Annotationen:
\begin{itemize}
\item \textbf{@NpmPackage}: importiert JavaScript-Pakete (ol, ol-ext, ol-layerswitcher, ol-popup) in der angegebenen Version.
\item \textbf{@Tag}: definiert das HTML-Tag als \textbf{openlayers}.
\item \textbf{@JsModule}: verweist auf die JavaScript-Datei \textbf{openlayers-connector.js} zur Client-Integration.
\end{itemize}
Methoden:
\begin{itemize}
	\item \textbf{showStationsOnMap(List<T> stations)}: zeigt Stationen auf der Karte an und erkennt, ob es sich um Wetterstationen handelt.
	\item \textbf{buildStationsJson(List<T> stations)}: konvertiert die Stationen-Liste in ein JSON-Array für die Client-Seite.
	\item \textbf{initConnector()}: Initialisiert den JavaScript-Connector(initLazy).
\end{itemize}

\section*{\small \textbf{3. Die Filtermöglichkeiten}}
\begin{lstlisting}
private FormLayout formLayout = new FormLayout();
private TextField tfMinLatitude = new TextField("Minimaler Breitengrad");
private TextField tfMaxLatitude = new TextField("Maximaler Breitengrad");
private TextField tfMinLongitude = new TextField("Minimaler Längengrad");
private TextField tfMaxLongitude = new TextField("Maximale Längengrad");
private Button btnFilterStations = new Button("Filtern");

tfMinLatitude.setPlaceholder("Minimaler Breitengrad eingeben (47.2701 bis 55.0581)");
tfMaxLatitude.setPlaceholder("Maximaler Breitengrad eingeben (47.2701 bis 55.0581)");
tfMinLongitude.setPlaceholder("Minimaler Längengrad eingeben  (5.8663 bis 15.0419)");
tfMaxLongitude.setPlaceholder("Maximaler Längegrad eingeben (5.8663 bis 15.0419)");
tfMinLatitude.setValue("50.323");
tfMaxLatitude.setValue("52.531");
tfMinLongitude.setValue("5.866");
tfMaxLongitude.setValue("9.462");

btnFilterStations.addThemeVariants(ButtonVariant.LUMO_PRIMARY);
btnFilterStations.addClickListener(submit -> {
	double minLat = Double.parseDouble(tfMinLatitude.getValue());
	double maxLat = Double.parseDouble(tfMaxLatitude.getValue());
	double minLon = Double.parseDouble(tfMinLongitude.getValue());
	double maxLon = Double.parseDouble(tfMaxLongitude.getValue());
	
	if (ddProvider.getValue() != null) {
		ddProvider.setValue(null);
	}
	
	List<StationDTO> filteredStations = mergedStations.stream()
	.filter(station -> station.getLatitude() >= minLat && station.getLatitude() <= maxLat
	&& station.getLongitude() >= minLon && station.getLongitude() <= maxLon)
	.collect(Collectors.toList());
	
	if (filteredStations.isEmpty()) {
		Utils.showHinweisBox("Keine Stationen innerhalb der Bounding Box gefunden.");
	} else {
		dataProviderStations = stationGrid.setItems(filteredStations);
		initOpenLayersMap();
		updateHeaderRows();
	}
	countResult.setText(dataProviderStations.getItemCount() + " Ergebnisse gefunden zu " + tfSearch.getValue());
});
formLayout.setWidth("65%");
formLayout.setResponsiveSteps(new FormLayout.ResponsiveStep("0", 1), 
new FormLayout.ResponsiveStep("500px", 2));
\end{lstlisting}
Dieser Code-Abschnitt erstellt ein Formular zur Filterung von Stationen anhand von Koordinaten (Breitengrad und Längengrad).\\
Formularkomponenten:
\begin{itemize}
	\item Vier \textbf{Textfelder:}: Eingabe von minimalen und maximalen Breiten- und Längengraden.
	\item Button \textbf{Filtern}: Startet den Filterprozess.
\end{itemize}
Filterlogik beim Button-Klick:
\begin{itemize}
	\item holt die eingegebenen Koordinaten und filtert die mergedStations-Liste.
	\item aktualisiert \textbf{dataProviderStations} mit den gefilterten Stationen.
	\item aktualisiert die Karte mit \textbf{initOpenLayersMap()} und die Header-Row.
\end{itemize}

\begin{lstlisting}
private Map<String, List<? extends StationDTO>> providerList = new HashMap<>();
ddProvider.setLabel("Servicename(n) auswählen");
ddProvider.setItemLabelGenerator(String::toString);
ddProvider.setWidth("20%");
	
ddProvider.addValueChangeListener(event -> {
	stationGrid.getHeaderRows().clear();
	if (event.getValue() != null) {
		List<? extends StationDTO> selectedStations = providerList.get(event.getValue());
		if (selectedStations != null) {
		if (tfMaxLatitude.getValue() != null && tfMinLongitude.getValue() != null) {
			GridListDataView<StationDTO> dataView = stationGrid.getListDataView();
			if (event.getValue().equals("OpenGeoData-NRW")) {
					dataView.setFilter(st -> selectedStations.contains(st));
					providerColumn.setHeader("Gebiet");
			} else if (event.getValue().equals("Pegelonline-Dienst")) {
					dataView.setFilter(st -> selectedStations.contains(st));
					providerColumn.setHeader("Provider");
			} else {
					dataView.setFilter(st -> st.getProvider().equals(event.getValue()));
					providerColumn.setHeader("Provider");
			}
			dataProviderStations = dataView;
		} else {
			if (event.getValue().equals("OpenGeoData-NRW")) {
				providerColumn.setHeader("Gebiet");
			} else {
				providerColumn.setHeader("Provider");
			}
				dataProviderStations = stationGrid.setItems(selectedStations.stream()
				.sorted(Comparator.comparing(StationDTO::getName))
				.collect(Collectors.toList()));
			}
			updateHeaderRows();
		} else {
			providerColumn.setHeader("Provider/Gebiet");
			dataProviderStations = stationGrid.setItems(mergedStations);
			updateHeaderRows();
		}
		stationGrid.getDataProvider().refreshAll();
		initOpenLayersMap();
		countResult.setText(dataProviderStations.getItemCount() + " Ergebnisse zu " + tfSearch.getValue()
		+ (event.getValue() != null ? " von " + event.getValue() : ""));
});
\end{lstlisting}
Dieser Code-Abschnitt implementiert die Filterlogik für den Dropdown-Provider.\\
Filterlogik bei Wertänderung:
\begin{itemize}
	\item Überprüft, ob ein Dienstanbieter \textbf{(event.getValue())} ausgewählt ist:
	\begin{itemize}
		\item falls Koordinatenfilter aktiv: verwendet \textbf{GridListDataView}, um die gefilterten Stationen weiter zu filtern.
		\item falls kein Koordinatenfilter: sortiert und setzt die Stationen basierend auf dem Dienstanbieter und aktualisiert die Header-Überschrift.
	\end{itemize}
	\item Falls kein Anbieter ausgewählt ist: setzt die ursprüngliche List als Datensatz und setzt die Standard-Header-Überschrift.
	\item Aktualisiert die Karte mit \textbf{initOpenLayersMap()} und die Header-Zeilen. 
\end{itemize}
\textbf{GridListDataView} ist eine Schnittstelle in Vaadin, die es ermöglicht, die Daten eines Grid-Components zu verwalten und zu manipulieren.
\clearpage
Wenn \textbf{OpenGeoData-NRW} als Eintrag aus dem Dropdown ausgewählt wird, ergibt sich folgende Abbildung:
\begin{figure}[H]
	\centering
	\includegraphics[width=18cm]{pegel-opengeodata.png}
	\caption{\label{}Pegel-OpenGeoDataNrw}
\end{figure}
\chapter{Fazit und Ausblick}

\section{Bewertung}
Bei der Bewertung  zwei grundlegende Aspekte näher betrachtet und kritisch analysiert: die technische Implementierung sowie das Architekturdesign. Der Fokus liegt dabei insbesondere auf der Frage, inwiefern die ursprüngliche formulierten Anforderungen im Verlauf der Entwicklung erfolgreich umgesetzt werden konnten.\\ \\
Im Rahmen der Arbeit ergeben sich zwei hauptsächlich folgende Forschungsfragen:
\begin{itemize}
	\item Lässt sich ein generisches Mapping umsetzen, um die heterogenen Datenstrukturen in eine einheitliche Datenstruktur zu überführen.
	\item Kann eine einheitliche Schnittstelle implementiert werden, die es eine Client-Applikation ermöglicht,in diesem Fall der AhuManager, gezielt einzelnen Datensätze mit dem gewünschten Zielformat zu abonnieren?
\end{itemize}
\subsection{Bewertung von Implementierung}
Zu der ersten Frage, konnte ein generisches Mapping  erfolgreich implementiert werden, um heterogene Datenstrukturen in ein einheitliches Format zu überführen. Dies wurde exemplarisch anhand von drei unterschiedlichen Datenquellen – dem \textbf{Deutschen Wetterdienst},\textbf{OpenGeoData.NRW} und \textbf{PegelOnline} – umgesetzt. Für diese Quellen funktioniert das Mapping zuverlässig. Allerdings ist die aktuelle Lösung nicht vollständig generisch im Hinblick auf beliebige, unbekannte Datenstrukturen. Für weitere Datenquellen mit stark abweichenden Strukturen sind gegebenenfalls spezifische Anpassungen notwendig, wodurch die generische Anwendbarkeit in solchen Fällen eingeschränkt ist.\\ \\
Zu der zweiten Frage, konnte eine einheitliche Schnittstelle im Rahmen dieser prototypischen Entwicklung realisiert werden. Diese REST-Schnittstelle ermöglicht es einer Client-Applikation – wie in diesem Fall dem \textbf{AhuManager} – gezielt einzelne Datensätze im gewünschten Zielformat zu abonnieren. Derzeit ist die Schnittstelle jedoch nur lokal (localhost) verfügbar, weshalb sie für den produktiven Einsatz noch entsprechend angepasst werden muss, um einen stabilen Datenaustausch zwischen Service und Client auch über Netzwerkgrenzen hinweg zu ermöglichen.

\subsection{Bewertung von Architekturdesign und Technologien}
Um eine Architektur einer Software bewerten zu können,werden unter anderem die \textbf{SOLID-Prinzipien} herangezogen. Diese definieren,wie Funktionen und Datenstrukturen in Klassen organisiert sowie wie Abhängigkeiten zwischen Klassen gestaltet sein sollen. Ziel ist die Entwicklung wartbarer, verständlicher und wiederverwendbarer Softwarekomponenten, die als stabile Grundlage für vielfältige Softwaresysteme dienen.\\
Die fünf SOLID-Prinzipien im Überblick:
\begin{itemize}
	\item \textbf{S} - Single-Responsibility-Prinzip(SRP): Eine Klasse sollte genau eine Verantwortlichkeit besitzen.
	\item \textbf{O} - Open-Closed-Prinzip(OCP): Softwaremodule sollen für Erweiterungen offen, aber für Modifikationen geschlossen sein.
	\item \textbf{L} - Liskov’sche Substitutions-Prinzip(LSP): Objekte von Subklassen sollen sich wie Objekte ihrer Superklasse verhalten lassen. 
	\item \textbf{I} - Interface-Segregation-Prinzip(ISP): Schnittstellen sollen spezifisch auf konkrete Anforderungen zugeschnitten sein.
	\item \textbf{D} - Dependency-Inversion-Prinzip(DIP): Abhängigkeiten sollen sich auf Abstraktionen, nicht auf konkrete Implementierung beziehen.
\end{itemize}
Im vorliegenden Projekt wurden mehrere dieser Prinzipien umgesetzt.
\begin{itemize}
	\item \textbf{Single-Responsibility-Prinzip} : Wie bereits in Abbildung 4.2 dargestellt, wurde dieses Prinzip konsequent umgesetzt. Jede Komponente bzw. jeder Service ist in einem eigenen Package gekapselt und übernimmt eine klar abgegrenzte Aufgabe.
	\item \textbf{Liskov Substitution Principle}: Auch dieses Prinzip wurde berücksichtigt. So stellt z.B. die Klasse \textbf{„BaseEntity“} eine abstrakte Oberklasse dar, deren Subklassen ihre zugesicherten Eigenschaften einhalten. Die Anwendung dieses Prinzips wurde im Detail in Abschnitt 5.1 erläutert.
	\item \textbf{Dependency-Inversion-Prinzip}: Durch den Einsatz des Spring Frameworks wird dieses Prinzip weitgehend automatisch unterstützt. Insbesondere durch die Verwendung der Annotation \textbf{@Autowird} erfolgen Abhängigkeiten auf Basis von Interfaces bzw. Abstraktionen und nicht auf konkrete Implementierungen.
\end{itemize}
Für die Umsetzung der spezifizierten Anforderungen wurden bewährte Technologien eingesetzt, die eine effiziente Entwicklung und eine benutzerfreundliche Darstellung der Ergebnisse ermöglichen.\\ \\
Im Backend kam das Spring Framework zum Einsatz, das durch seine modulare Struktur, umfangreiche Konfigurationsmöglichkeiten und integrierte Unterstützung für Dependency Injection eine schnelle und strukturierte Implementierung der Geschäftslogik erlaubt.\\ \\
Für die Gestaltung der Benutzeroberfläche wurde Vaadin verwendet. Diese Java-basierte Web-UI-Technologie bietet eine Vielzahl an vorkonfigurierten Komponenten, die sich besonders gut zur Darstellung großer Datenmengen eignen. Durch die hohe Abstraktionsebene und serverseitige Verarbeitung lassen sich komplexe Benutzeroberflächen mit minimalem Aufwand realisieren. Insbesondere die Möglichkeit, Messdaten übersichtlich und interaktiv anzuzeigen, stellt einen wesentlichen Vorteil von Vaadin im vorliegenden Projekt dar.
\section{Ausblick}
Die zentrale Fragestellung zu Beginn dieser Arbeit lautete, ob die prototypische Entwicklung zur Messdatenerhebung und -bereitstellung einen konkreten Mehrwert für den \textbf{AhuManager} liefern kann. Diese Frage lässt sich nicht abschließend beantworten, bietet jedoch Diskussionspotenzial.Der entwickelte Prototyp bildet eine solide Grundlage, auf der weiter aufgebaut werden kann.\\
Insbesondere in folgenden Punkten besteht Weiterentwicklungspotenzial:
\begin{itemize}
	\item \textbf{Ausbau der Schnittstellen}: Die Anbindung eines stabilen und skalierbaren Abonnement-Services könnte die Datenbereitstellung effizienter und flexibler gestalten.
	\item \textbf{Integration weiterer Datenquellen}: Eine Erweiterung auf zusätzliche externe Systeme würde Mehrwert bringen.
	\item \textbf{Verbesserung der Benutzeroberfläche}: Die grafische Darstellung und Interaktivität der Oberfläche lässt sich im Hinblick auf Usability und Performance weiter optimieren.
\end{itemize}
Ein spannender Aspekt für die zukünftige Entwicklung wäre die Frage,ob sich eine \textbf{generalisierte Datenstruktur} realisieren lässt, in der alle abonnierten Daten einheitlich in einer Datenbank abgelegt werden können-beispielsweise angelehnt an das \textbf{SensorThings API-Modell}. Eine solche Standardisierung könnte die Interoperabilität zwischen verschiedenen Systemen wesentlich verbessern.	
\printbibliography
\end{document}